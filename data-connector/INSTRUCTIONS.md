# Instructions

## Initial setup
Install a Curiosity Workspace to your system using the following instructions:

### Windows

- Download the Curiosity Workspace for Windows install file (here)[https://downloads.curiosity.ai/workspace/windows]
- Run the setup, and follow the instructions to install.
- Once installed, open your start menu and run the "Curiosity Workspace" app

### Docker:

You must configure the values that are required for a standard installation. Unlike in the Installation guide, you cannot use a YAML file in the root folder of the app, therefore pass the configuration variables directly to the docker run command:

```bash
mkdir -p ~/curiosity/storage
docker run -p 8080:8080 -v ~/curiosity/storage/:/data/ -e storage=/data/curiosity
```

If you're running on Windows, you will need to adapt the paths as required:

```bash
mkdir c:\curiosity\storage
docker run -p 8080:8080 -v c:/curiosity/storage/data/:/data/ -e storage=/data/curiosity
```

## First Steps

Navigate to your workspace on your browser (http://localhost:8080) and login with with user and password `admin`. Follow the steps to give your workspace a name, and proceed till the end.

### Develop a Curiosity Connector Template

Navigate to the administrative management interface (Manage icon on the botton sidebar), then open `API integrations` and click on the C# icon on the bottom right corner. Your task is to write a data connector that maps the files in the dataset into the graph, creating the right nodes and edges based on the raw JSON data.

Alternativelly, you can also open the included data connector sample in this folder (i.e. `TechSupport.DataConnector.csproj`).

### Defining Schemas in a data connector

This is one approach to model the data into a graph. We group all node and edge schemas in a `Schema.cs` file, that can also be automatically regenerated by the application. As we're getting started from an empty system, we model directly the schemas in this file. Besides the expected node types derived from the files (devices, parts, support cases) we also add two extra node types () Manufacturer and Status properties as nodes on the graph, instead of as fields of the objects. This can be useful for providing navigation and filtering features using graph queries (for example, all support cases from a manufacturer), or to have shared filters that work across multiple data types (for example, if we would have other data types with a Status field).

```csharp
[Node]
public class Device
{
    [Key] public string Name { get; set; }
}

[Node]
public class Part
{
    [Key] public string Name { get; set; }
}

[Node]
public class Manufacturer
{
    [Key] public string Name { get; set; }
}

[Node]
public class SupportCase
{
    [Key] public string Id { get; set; }
    [Property] public string Summary { get; set; }
    [Property] public string Content { get; set; }
    [Timestamp] public DateTimeOffset Time { get; set; }
}

[Node]
public class Status
{
    [Key] public string Value { get; set; }
}
```

These node definitions can be syncronized directly in the graph using by calling:

```csharp
await graph.CreateNodeSchemaAsync<Nodes.Device>();
```


For defining the edges in the data connector, it is useful to use a static class with the edge names as constants, to be able to easily refer to them without having to use strings everywhere in the code base:

```csharp
public static class Edges
{
    public const string HasPart= nameof(HasPart);
    public const string PartOf = nameof(PartOf);
    public const string HasSupportCase = nameof(HasSupportCase);
    public const string ForDevice = nameof(ForDevice);
    public const string HasManufacturer = nameof(HasManufacturer);
    public const string ManufacturerOf = nameof(ManufacturerOf);
    public const string HasStatus = nameof(HasStatus);
    public const string StatusOf = nameof(StatusOf);
}
```

The data connector can automatically identify all fields following this pattern in a static class and create the required edge schemas in the graph:

```csharp
await graph.CreateEdgeSchemaAsync(typeof(Edges));
```

### Ingesting data

We can structure the data ingestion around reading and mapping the data into the graph. As the source dataset is provided as JSON files, we can simply read them in memory using `System.Text.Json` to desserialize them:

```csharp
var devices = JsonConvert.DeserializeObject<DeviceJson[]>(File.ReadAllText(Path.Combine("..", "data", "devices.json")));
var parts   = JsonConvert.DeserializeObject<PartJson[]>(File.ReadAllText(Path.Combine("..", "data", "parts.json")));
var cases   = JsonConvert.DeserializeObject<SupportCaseJson[]>(File.ReadAllText(Path.Combine("..", "data", "support-cases.json")));
```


Ingesting the devices dataset can be done by simply interating over the dataset and creating a new object of the type Device (see annotated schema above):

```csharp
foreach (var device in devices)
{
    graph.TryAdd(new Nodes.Device() { Name = device.Name });
}
```


For the parts dataset, we can extract a few relationships from the data. For example, we can link each part `Manufacturer` field to a `Manufacturer` node, and each part to one or more `Device` nodes based on the `Devices` array:

```csharp
foreach (var part in parts)
{
    var partNode = graph.TryAdd(new Nodes.Part() { Name = part.Name });

    if (!string.IsNullOrWhiteSpace(part.Manufacturer))
    {
        var manufacturerNode = graph.TryAdd(new Nodes.Manufacturer() { Name = part.Manufacturer });
        graph.Link(partNode, manufacturerNode, Edges.HasManufacturer, Edges.ManufacturerOf);
    }

    foreach (var device in part.Devices)
    {
        graph.Link(partNode, Node.Key(nameof(Nodes.Device), device), Edges.PartOf, Edges.HasPart);
    }
}
```

Finally, we can ingest the support cases data. Here we don't have a unique field to represent the key for the node, so we create one sequentially during ingestion. Alternativelly, you can use a deterministic hash from the data to create a unique identifier. You can also use random identifiers if you have none, but just remember that if you run the connector twice, you might end up with duplicated data. We can also map each `SupportCase` to a `Status` node.

```csharp
var supportCaseId = 0;
foreach (var supportCase in cases.OrderBy(t => t.Time))
{
    var supportCaseNode = graph.TryAdd(new Nodes.SupportCase() { Id = $"SC-{supportCaseId:0000}", Content = supportCase.Content, Summary = supportCase.Summary, Time = supportCase.Time });

    var statusNode = graph.TryAdd(new Nodes.Status { Value = supportCase.Status });
    graph.Link(supportCaseNode, statusNode, Edges.HasStatus, Edges.StatusOf);
    supportCaseId++;
}
```

Finally, before returning, you can also ensure all pending operations are commited by calling `CommitPendingAsync`. This will also be automatically done for you when the graph object is disposed, but it is good practice to call it directly.

```csharp
await graph.CommitPendingAsync();
```


### Run the data connector

In order to run the data connector, you'll need to first generate an API token for the connector. For that, navigate to the administrative management interface (Manage icon on the botton sidebar), then open `API integrations` and click on the "Create API Token" button. Give the token a name and validity, and copy the resulting token. If you're using the included data connector sample, add it as the `CURIOSITY_API_TOKEN` environment variable for running the project.


## Explore the data into the system

Navigate to the administrative management interface (Manage icon on the botton sidebar), then open `Data` and click on one of the node schemas your connector has created (for example Device or Part). Use the Overview feature to undestand how many nodes exist in the graph, and what kind of relationships the data has.


### Use the shell to explore the data

The shell provides a way for administrators to run code and queries against the workspace graph database. It is useful during development to explore and understand the data, but it can also be used for more advanced tasks such as data migrations or exports.

In order to open the shell, navigate to the administrative management interface and click on `Shell`

#### Sample queries

- Return some devices:
```csharp
return Q().StartAt(N.Device.Type).Take(10).Emit("N");
```

- Return all parts made by Apple:
```csharp
return Q().StartAt(N.Manufacturer.Type, "Apple").Out(N.Part.Type).Emit("N");
```

- Return the latest support cases:
```csharp
return Q().StartAt(N.SupportCase.Type).SortByTimestamp(oldestFirst:false).Take(10).Emit("N");
```

- Return the summary of relationships of a given node type
```csharp
return Q().StartAt(N.Part.Type).EmitNeighborsSummary();
```

- Return the whole graph summary:
```csharp
return Q().EmitSummary();
```

- Return the whole graph relationships summary:
```csharp
return Q().EmitNeighborsSummary();
```

- Count how many parts each manufacturer has
```csharp
return Q().StartAt(N.Manufacturer.Type).AsEnumerable().ToDictionary(n => n.GetString(N.Manufacturer.Name), n => Q().StartAt(n.UID).Out(N.Part.Type).Count());
```

- Finding all devices that have a manufacturer name in the device name

```csharp
var manufacturers = Q().StartAt(N.Manufacturer.Type).AsEnumerable().Select(n => n.GetString(N.Manufacturer.Name)).ToArray();
var devicesPerManufacturer = new Dictionary<string, string[]>();

foreach(var m in manufacturers)
{
    devicesPerManufacturer[m] = Q().StartAt(N.Device.Type).Where(n => n.GetString(N.Device.Name).Contains(m)).AsEnumerable().Select(n => n.GetString(N.Device.Name)).ToArray();
}

return devicesPerManufacturer;
```

- Add a relationship between devices and manufacturers

```csharp
foreach(var manufacturerNode in Q().StartAt(N.Manufacturer.Type).AsEnumerable())
{
   var manufacturerName = manufacturerNode.GetString(N.Manufacturer.Name);
   await Q().StartAt(N.Device.Type).Where(n => n.GetString(N.Device.Name).Contains(manufacturerName))
            .Tx()
            .AddUniqueEdgeTo(E.HasManufacturer, manufacturerNode.UID)
            .AddUniqueEdgeFrom(E.ManufacturerOf, manufacturerNode.UID)
            .CommitAsync();
}

return Q().StartAt(N.Device.Type).EmitNeighborsSummary();
```


