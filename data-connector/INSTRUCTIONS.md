# Curiosity Workspace // Data Connectors

Welcome to the Curiosity Workspace Data Connector Guide! This document will walk you through the process of setting up a data connector, and integrating your data into a graph structure. By the end of this guide, you’ll have a Curiosity Workspace with some data inside of it, a clear understanding of how to define schemas, ingest data, and explore the resulting graph database.

Let’s get started!

## Table of Contents

1. [Develop a Curiosity Connector Template](#develop-a-curiosity-connector-template)
2. [Defining Schemas in a Data Connector](#defining-schemas-in-a-data-connector)
3. [Ingesting Data](#ingesting-data)
4. [Run the Data Connector](#run-the-data-connector)
5. [Explore the Data in the System](#explore-the-data-into-the-system)
6. [Use the Shell to Explore the Data](#use-the-shell-to-explore-the-data)
   - [Sample Queries](#sample-queries)

---

### Develop a Curiosity Connector Template

Navigate to the administrative management interface (Manage icon on the botton sidebar), then open `API integrations` and click on the C# icon on the bottom right corner. Your task is to write a data connector that maps the files in the dataset into the graph, creating the right nodes and edges based on the raw JSON data.

We suggest you to open the included data connector sample in this folder (i.e. `TechnicalSupport.DataConnector.csproj`) so you can follow better the explanations below.

### Defining Schemas in a data connector

This is one approach to model the data into a graph. We group all node and edge schemas in a `Schema.cs` file, that can also be automatically regenerated by the application. As we're getting started from an empty system, we model directly the schemas in this file. Besides the expected node types derived from the files (devices, parts, support cases) we also add a `Manufacturer` and `Status` node type to model those values as first-class graph nodes (instead of only storing them as fields). This can be useful for providing navigation and filtering features using graph queries (for example, all support cases from a manufacturer), or to have shared filters that work across multiple data types (for example, if we would have other data types with a Status field).

The sample connector also defines two additional node types that are derived from the support case content:
* `SupportCaseMessage`, which stores individual user/support messages extracted from the `SupportCase.Content` transcript.
* `SupportChatContext`, included in the schema for potential future use.

```csharp
[Node]
public class Device
{
    [Key] public string Name { get; set; }
}

[Node]
public class Part
{
    [Key] public string Name { get; set; }
}

[Node]
public class Manufacturer
{
    [Key] public string Name { get; set; }
}

[Node]
public class SupportCase
{
    [Key] public string Id { get; set; }
    [Property] public string Summary { get; set; }
    [Property] public string Content { get; set; }
    [Property] public string Status { get; set; }
    [Timestamp] public DateTimeOffset Time { get; set; }
}

[Node]
public class Status
{
    [Key] public string Value { get; set; }
}

[Node]
public class SupportCaseMessage
{
    [Key] public string Id { get; set; }
    [Property] public string Author { get; set; }
    [Property] public string Message { get; set; }
    [Timestamp] public DateTimeOffset Time { get; set; }
}

[Node]
public class SupportChatContext
{
    [Key] public string ID { get; set; }
    [Property] public string Topic { get; set; }
}
```

These node definitions can be syncronized directly in the graph using by calling:

```csharp
await graph.CreateNodeSchemaAsync<Nodes.Device>();
```


For defining the edges in the data connector, it is useful to use a static class with the edge names as constants, to be able to easily refer to them without having to use strings everywhere in the code base:

```csharp
public static class Edges
{
    public const string HasPart= nameof(HasPart);
    public const string PartOf = nameof(PartOf);
    public const string HasSupportCase = nameof(HasSupportCase);
    public const string ForDevice = nameof(ForDevice);
    public const string HasManufacturer = nameof(HasManufacturer);
    public const string ManufacturerOf = nameof(ManufacturerOf);
    public const string HasStatus = nameof(HasStatus);
    public const string StatusOf = nameof(StatusOf);
    public const string HasMessage = nameof(HasMessage);
    public const string MessageOf = nameof(MessageOf);
}
```

The data connector can automatically identify all fields following this pattern in a static class and create the required edge schemas in the graph:

```csharp
await graph.CreateEdgeSchemaAsync(typeof(Edges));
```

### Ingesting data

We can structure the data ingestion around reading and mapping the data into the graph. As the source dataset is provided as JSON files, we can simply read them in memory using `Newtonsoft.Json` (as shown in the sample connector) to deserialize them:

```csharp
var devices = JsonConvert.DeserializeObject<DeviceJson[]>(File.ReadAllText(Path.Combine("..", "data", "devices.json")));
var parts   = JsonConvert.DeserializeObject<PartJson[]>(File.ReadAllText(Path.Combine("..", "data", "parts.json")));
var cases   = JsonConvert.DeserializeObject<SupportCaseJson[]>(File.ReadAllText(Path.Combine("..", "data", "support-cases.json")));
```


Ingesting the devices dataset can be done by simply interating over the dataset and creating a new object of the type Device (see annotated schema above):

```csharp
foreach (var device in devices)
{
    var deviceNode = graph.TryAdd(new Nodes.Device() { Name = device.Name });
    graph.AddAlias(deviceNode, Mosaik.Core.Language.Any, device.Name.Replace("-", " "), ignoreCase: false);
    graph.AddAlias(deviceNode, Mosaik.Core.Language.Any, device.Name.Replace("-", "."), ignoreCase: false);
}
```


For the parts dataset, we can extract a few relationships from the data. For example, we can link each part `Manufacturer` field to a `Manufacturer` node, and each part to one or more `Device` nodes based on the `Devices` array:

```csharp
foreach (var part in parts)
{
    var partNode = graph.TryAdd(new Nodes.Part() { Name = part.Name });

    if (!string.IsNullOrWhiteSpace(part.Manufacturer))
    {
        var manufacturerNode = graph.TryAdd(new Nodes.Manufacturer() { Name = part.Manufacturer });
        graph.Link(partNode, manufacturerNode, Edges.HasManufacturer, Edges.ManufacturerOf);
    }

    foreach (var device in part.Devices)
    {
        graph.Link(partNode, Node.FromKey(nameof(Nodes.Device), device), Edges.PartOf, Edges.HasPart);
    }
}
```

Finally, we can ingest the support cases data. Here we don't have a unique field to represent the key for the node, so we create one sequentially during ingestion. Alternativelly, you can use a deterministic hash from the data to create a unique identifier. You can also use random identifiers if you have none, but just remember that if you run the connector twice, you might end up with duplicated data. We can also map each `SupportCase` to a `Status` node.

```csharp
var supportCaseId = 0;
foreach (var supportCase in cases.OrderBy(t => t.Time))
{
    var supportCaseNode = graph.TryAdd(new Nodes.SupportCase()
    {
        Id = $"SC-{supportCaseId:0000}",
        Content = supportCase.Content,
        Summary = supportCase.Summary,
        Time = supportCase.Time,
        Status = supportCase.Status
    });

    var statusNode = graph.TryAdd(new Nodes.Status { Value = supportCase.Status });
    graph.UnlinkExcept(supportCaseNode, statusNode, Edges.HasStatus, Edges.StatusOf);
    graph.Link(supportCaseNode, statusNode, Edges.HasStatus, Edges.StatusOf);

    graph.Link(supportCaseNode, Node.FromKey(nameof(Nodes.Device), supportCase.Device), Edges.ForDevice, Edges.HasSupportCase);    
    supportCaseId++;
}
```

The sample connector also parses the transcript in `SupportCase.Content` to create `SupportCaseMessage` nodes (authored by "User" or "Support") and links them to the parent case with `HasMessage` / `MessageOf` edges. This provides more granular chat history in the graph and can be used for timeline views or analytics.

Finally, before returning, you can also ensure all pending operations are commited by calling `CommitPendingAsync`. This will also be automatically done for you when the graph object is disposed, but it is good practice to call it directly.

```csharp
await graph.CommitPendingAsync();
```


### Run the data connector

In order to run the data connector, you'll need to first generate two tokens, an API token for the connector and an enpoint token. The sample connector also calls example endpoints (`hello-world`, `long-running-hello-world`, and `replay`) after ingestion, so you will need a valid endpoints token even if you only intend to ingest data. If you do not want to call endpoints, you can comment out the `TestEndpointsAsync` call in `App.cs`.
For the API token, navigate to the administrative management interface (Manage icon on the botton sidebar), then open `API integrations` and click on the "Create API Token" button. Give the token a name and validity, and copy the resulting token. If you're using the included data connector sample, add it as the `CURIOSITY_API_TOKEN` environment variable for running the project.
For the Endpoint token, navigate to administrative management interface (Manage icon on the botton sidebar), then open `Tokens` and click on the plus button on the right top corner and select `Endpoints`. Give the token a name, validity and scope it if you want to some specific endpoint paths, and copy the resulting token. If you're using the included data connector sample, add it as the `CURIOSITY_ENDPOINTS_TOKEN` environment variable for running the project.



## Explore the data into the system

Navigate to the administrative management interface (Manage icon on the botton sidebar), then open `Data` and click on one of the node schemas your connector has created (for example Device or Part). Use the Overview feature to undestand how many nodes exist in the graph, and what kind of relationships the data has.


### Use the shell to explore the data

The shell provides a way for administrators to run code and queries against the workspace graph database. It is useful during development to explore and understand the data, but it can also be used for more advanced tasks such as data migrations or exports.

In order to open the shell, navigate to the administrative management interface and click on `Shell`

#### Sample queries

- Return some devices:
```csharp
return Q().StartAt("Device").Take(10).Emit("N");
```

- Return all parts made by Apple:
```csharp
return Q().StartAt("Manufacturer", "Apple").Out("Part").Emit("N");
```

- Return the latest support cases:
```csharp
return Q().StartAt("SupportCase").SortByTimestamp(oldestFirst:false).Take(10).Emit("N");
```

- Return the summary of relationships of a given node type
```csharp
return Q().StartAt("Part").EmitNeighborsSummary();
```

- Return the whole graph summary:
```csharp
return Q().EmitSummary();
```

- Return the whole graph relationships summary:
```csharp
return Q().EmitNeighborsSummary();
```

- Count how many parts each manufacturer has
```csharp
return Q().StartAt("Manufacturer").AsEnumerable().ToDictionary(n => n.GetString("Name"), n => Q().StartAt(n.UID).Out("Part").Count());
```

- Finding all devices that have a manufacturer name in the device name

```csharp
var manufacturers = Q().StartAt("Manufacturer").AsEnumerable().Select(n => n.GetString("Name")).ToArray();
var devicesPerManufacturer = new Dictionary<string, string[]>();

foreach(var m in manufacturers)
{
    devicesPerManufacturer[m] = Q().StartAt("Device").Where(n => n.GetString("Name").Contains(m)).AsEnumerable().Select(n => n.GetString("Name")).ToArray();
}

return devicesPerManufacturer;
```

- Add a relationship between devices and manufacturers

```csharp
foreach(var manufacturerNode in Q().StartAt("Manufacturer").AsEnumerable())
{
   var manufacturerName = manufacturerNode.GetString("Name");
   await Q().StartAt("Device").Where(n => n.GetString("Name").Contains(manufacturerName))
            .Tx()
            .AddUniqueEdgeTo("HasManufacturer", manufacturerNode.UID)
            .AddUniqueEdgeFrom("ManufacturerOf", manufacturerNode.UID)
            .CommitAsync();
}

return Q().StartAt("Device").EmitNeighborsSummary();
```


## Conclusion

Great job! You’ve set up a Curiosity Workspace data connector and integrated data into the graph. You’ve learned how to:

- Develop a connector template
- Define schemas and relationships
- Ingest and map data into the graph
- Commit data and explore it using the system interface and shell

## Next steps
- Configure natural language processing parsing in the [NLP Configuration Guide](/nlp-configuration/INSTRUCTIONS.md)
- Configure search on the data in the [Search Configuration Guide](/search-configuration/INSTRUCTIONS.md)
